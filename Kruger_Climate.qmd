---
title: "Kruger Climate"
format: pdf
editor: visual
---

## Analysis

```{r, message=FALSE}
library(tidyverse)
source("~/Documents/Duke/Semesters/Spring 25/Ecology/Ecology/clarkFunctions2025.R")
load( 'annualClimateKruger.rdata', verbose = T )
load( 'monthlyClimateKruger.rdata', verbose = T )
load( 'herbivoreCensus.rdata', verbose = T )
```

Sector names combine the `region` and `substrate` columns. The area of each sector is given in hectares (`ha`). Note that there are only two substrates, the western granite and the eastern, more basic basalt.

The sector boundaries are held in the `list substratePoly`. These coordinates are given in `lon, lat`. There is one `matrix` for each `sector`. The two rows generated by `sapply` give the number of rows and columns in each of the matrices held in `substratePoly`.

All polygons have two columns. They differ in numbers of rows. Here is the first polygon in `substratePoly`:

```{r}
sapply( substratePoly, dim )
head( substratePoly[[1]], 4 ) 
```

Here are these polygons on a map, which I constructed like this:

-   specify map limits `xlim` and `ylim` (in `lon` and `lat`).

-   the column `substrateData$sector` holds sector names; assign a unique color to each

-   map the polygons for each `sector` using the `function polyMap`.

```{r}
# map limits
xlim <- c( 30.8, 32.1 )
ylim <- c( -25.6, -22.2 )

# sector colors, names
sectCols <- c('#003c30','#8dd3c7','#bebada','#fb8072','#80b1d3',
              '#fdb462','#b3de69','#b15928')
sectors  <- substrateData$sector                     

# draw map, add legend
polyMap( polyList = substratePoly, type = substrateData$sector,
         xaxt = 'n', yaxt = 'n', border = sectCols, col = sectCols )
legend( 'topright', legend = sectors, text.col = sectCols, bty = 'n' )
```

These sectors reference substrate types together with geographic locations (north, central, south).

# **Mapped climate variation**

The habitats and animals that reside in them depend on substrate and climate. Here I map substrate (granite, basalt) and two climate variables. The steps I use to generate these maps are:

-   map substrate using the `function polyMap`

-   evaluate mean temperature and moisture deficit for each grid point in the climate data

-   assign colors to the gradients in these two variables

-   map with the `function imageMap`

Here is the substrate map:

```{r}
subs  <- unique( substrateData$substrate )        
scols <- sramp[ c(1, nsect) ]

polyMap( polyList = substratePoly, type = substrateData$substrate,
         border = scols, xaxt = 'n', yaxt = 'n', col = scols, add = F )
axis(1, at = c( 31, 32 ) )
axis(2, at = c(-25, -24, -23), pos = 30.7, las = 1 )
legend( 'topright', legend = subs, text.col = scols, bty = 'n' )
title( 'Substrate' )
```

This map shows variation in average temperature:

```{r}
par( mfrow=c(1,2), bty = 'n', omi = c(.1,.1, .3, .4 ) )
siteTemp <- rowMeans( annualTemp, na.rm = T )   # climate mean by location

nlev <- 20
tfun <- colorRampPalette( rev( colRed2Blu ) ) # assign colors to climate gradients

# map climate
imageMap( lonLat, siteTemp, colRamp = tfun(nlev), xaxt = 'n', yaxt = 'n', xlim = xlim, ylim = ylim )
polyMap( polyList = substratePoly, type = substrateData$substrate, border = 'grey', lwd = 2, add = T )
title( 'Temperature' )

colorScaleLegend( xleg = c( 33, 33.3), yleg = c( -23, -22 ), zlim = round( range(siteTemp) ), 
                  xlim = xlim, ylim = ylim, ncol = nlev, units = '', colorRamp = tfun(nlev) ) 
```

This is moisture deficit, with high values indicating ‘dry’ conditions:

```{r}
siteDef <- rowMeans( annualDef, na.rm = T )
dfun    <- colorRampPalette( rev( colBrown2Green ) )

imageMap( lonLat, siteDef, colRamp = dfun(nlev),
          xlim = xlim, ylim = ylim, zlim = c(-900, 900), xaxt = 'n', yaxt = 'n' )
polyMap( polyList = substratePoly, type = substrateData$substrate, border = 'grey', lwd = 2, add = T )
title( 'Moisture deficit' )

colorScaleLegend( xleg = c( 33, 33.3), yleg = c( -23, -22 ), zlim = c(-900, 900), 
                  xlim = xlim, ylim = ylim, ncol = nlev, 
                  units = 'mm', colorRamp = dfun(nlev) ) 
```

## **Spatial variation**

I’ve selected three locations to display seasonal variation represented by different climates:

```{r}
lnames  <- c('lon','lat')
locs    <- rbind( c( 30.86, -25.2 ), c( 31.22513, -22.73519 ), c( 31.55659, -24.97129 ) ) 
dimnames( locs ) <- list( c( 'Thaba Chweu',  'Collins Chabane', 'Skukuza' ), c('lon','lat') )
```

I add these locations to the map:

```{r}
polyMap( polyList = substratePoly, type = substrateData$substrate,
         col = scols, xaxt = 'n', yaxt = 'n' )
points( locs[,1], locs[,2], pch = 16, col = 'white', cex = 1.4 )
points( locs[,1], locs[,2], pch = 16, col = 'black', cex = 1. )
text( locs[,1], locs[,2], rownames(locs), pos = 2 )
```

I compare the seasonal changes at these sites in the next section.

## **Monthly climate**

The annual averages in the foregoing map depend on seasonal variation. Here are the monthly data. They are stored as a location by `year_mo` matrix:

```{r}
load( 'monthlyClimateKruger.rdata', verbose = T )
```

As for annual data, rows in `temp` correspond to locations in `lonLat`.

To extract climate for each location, I first locate the closest climate grid point using the function `nn2` (nearest neighbor). To see that it worked, I use `polyMap` to show the climate grid with highlights on the nearest points to my three locations:

```{r}
mm    <- RANN::nn2( lonLat, locs, k = 1 )[[1]] # grid closest to three locations
nsite <- nrow(locs)
ll    <- lonLat[mm,]
```

![](images/Screenshot%202025-02-08%20at%204.58.25%20PM.png)

To do this in R I use the `YEAR_MO` format from the column names in `prec` and `pet` to identify years and months and then sum using `tapply`:

```{r}
yrMonth <- columnSplit( colnames( prec ), '_' )
year    <- as.numeric( yrMonth[,1] )
month   <- as.numeric( yrMonth[,2] )
yindex  <- rep( year, each = nrow(ll) )        # yr index repeated for number of sites (rows in ll)
sindex  <- rep( rownames( ll ), ncol( prec ) ) # site index repeated for number of YEAR_MO's

P   <- tapply( as.vector( prec[ rownames(ll),] ), list( sindex, yindex ), sum )
PET <- tapply( as.vector( pet[ rownames(ll),] ), list( sindex, yindex ), sum )
D   <- PET - P
```

Alternatively, I might want monthly averages over years:

```{r}
mindex <- rep( month, each = nrow(ll) )  # month index repeated for number of sites
P   <- tapply( as.vector( prec[ rownames(ll),] ), list( sindex, mindex ), mean )
PET <- tapply( as.vector( pet[ rownames(ll),] ), list( sindex, mindex ), mean )
D   <- PET - P
```

In this next block I have packed this away into a `function wideFormat2waterBalance`. Here is water balance at the three locations:

```{r}
# P and PET for 3 locations
prec1 <- prec[ rownames(ll),]
pet1  <- pet[ rownames(ll),]
rownames(prec1) <- rownames(pet1) <- rownames(locs)

par( mfrow = c(1,3), bty = 'n', mar = c( 3, 2, 4, 1), omi = c(.4,.5, .1, .1) )
wideFormat2waterBalance( prec1, pet1, years = c(2011:2020), ylim = c(0, 150),
                         ylab = '', yaxt = c('s', rep('n', (nsite-1)) ) )
mtext( 'Month', 1, line = 1, outer = T, cex = 1.2 )
mtext( 'P, PET (mm)', 2, line = 1, outer = T, las = 0, cex = 1.2 )
```

## **Climate change**

The climate time series can help us understand changing herbivore abundance. Here I find the climate grid points closest to sector centroids and plot time series for annual temperature and moisture deficit. To highlight trends I add shading when a series is above its mean value:

```{r}

mm <- RANN::nn2( lonLat, substrateData[,c('lon','lat')], k = 1 )[[1]]
sectTemp <- annualTemp[mm,]
sectDef  <- annualDef[mm,]
yr   <- as.numeric( colnames( sectTemp ) )
xlim <- range( yr )

# temperate series by sector
par( mfrow = c(1,2), bty = 'n', mar = c(4,4,1,1), omi = c(.5, .1, .1, .1) )
ylim <- range( sectTemp )

plot( NA, xlab = '', ylab = 'Degrees C', xlim = xlim, ylim = ylim, las = 1 )
for( k in 1:nsect){
  lines( yr, sectTemp[k,], col = sectCols[k], lwd = 2 )
  shadeThreshold( yr, sectTemp[k,], tmin = mean( sectTemp[k,] ), 
                  border = sectCols[k], col = .getColor( sectCols[k], .4) )
}
title( 'Temperature' )

# moisture deficit
ylim <- range( sectDef )
plot( NA, xlab = '', ylab = 'mm', xlim = xlim, ylim = ylim, las = 1  )
for( k in 1:nsect){
  lines( yr, sectDef[k,], col = sectCols[k], lwd = 2 )
  shadeThreshold( yr, sectDef[k,], tmin = mean( sectDef[k,] ), 
                  border = sectCols[k], col = .getColor( sectCols[k], .4) )
}
title( 'Moisture Deficit' )
mtext( 'Year', 1, outer = T, cex = 1.5 )


```

